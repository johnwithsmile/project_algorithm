/* Big O notation

왜 필요한가?

문제가 있을 때 여러가지 해결방법이 있을 수 있음. 어떤게 더 좋은지 알 수 있을까?

빅O가 여기서 나옴 여러가지 코드를 평가함.
좋다/ 나쁘다 대신에 구체적으로 표현하는 것임.

작동하기만 하면 상관 없는거 아님?
사실이지만 면접이나 코드 챌린지, 데이터가 훨씬 커질 때 작은 차이는 엄청나게 커질 수 있음. 그 때에는 성능이 중요해짐

그러니 자신이 만든 해결책에 만족하는것도 중요하지만 가장 효율적인 것을 찾는게 좋음.

1에서 n까지의 모든 수를 더해주는 걸로 만들어보면 */

function addUpto(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}

console.log(addUpto(6));

// 하지만 이렇게도 됨

function addUpto(n) {
  return (n * (n + 1)) / 2;
}
console.log(addUpto(6));
/* 
그럼 두 코드에서 뭐가 더 나은지 어케 비교하는가?
나은의 정의는
1. 더 빠른가
2. 메모리를 적게 쓰는가
그리고 읽기 쉬운가가 추가될 수 있음.
그래서 어떻게 재는데?
 */

function addUpto(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
let t1 = performance.now();
addUpto(1000000000);
let t2 = performance.now();
console.log(`Time Elapsed: ${(t2 - t1) / 1000} seconds.`);

/* 이렇게 큰 수를 넣고 시간을 재는 것임
이 코드에서 let t1 = performance.now();은 성능 측정을 위한 시작 시간을 기록하는 역할을 합니다. performance.now()는 브라우저에서 제공하는 메서드로, 현재 시간을 밀리초 단위로 반환합니다.

let t1은 성능 측정을 위한 변수를 선언하고, performance.now()를 호출하여 현재 시간을 가져옵니다. 이렇게 하면 코드 실행의 시작 시간이 기록됩니다.

다음으로, addUpto(1000000000);이 호출되면 addUpto 함수가 실행됩니다. 이 함수는 1부터 n까지의 모든 수를 더한 총합을 계산합니다. 이를 위해 반복문을 사용하여 total 변수에 i를 더해가며 총합을 계산합니다.

return total;을 통해 총합이 반환되고, 이 값은 현재는 무시됩니다.

let t2 = performance.now();는 성능 측정을 위한 종료 시간을 기록하는 역할을 합니다. 다시 한 번 performance.now()를 호출하여 현재 시간을 가져옵니다. 이렇게 하면 코드 실행의 종료 시간이 기록됩니다.

마지막으로, console.log()를 사용하여 실행 시간을 출력합니다. (t2 - t1)을 통해 실행 시간을 계산하고, 1000으로 나누어 초 단위로 변환합니다. 이를 "Time Elapsed: ${실행 시간} seconds."와 함께 출력합니다.

이렇게 함으로써 addUpto(1000000000);의 실행에 걸린 시간을 측정하고 출력할 수 있습니다.

하지만 이렇게는 계속 측정값이 바뀌게 됨, 기계에 따라서 측정되는 시기에 따라서도 다를 수 있음.
그리고 엄청 빠르게 처리되느라 충분히 정확하지 않을 수 있음. 

그래서 빅오가 등장한다.
 */
